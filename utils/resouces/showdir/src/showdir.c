#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/select.h>
#include "subshowdir.h"

int main(int argc, char* argv[]) {
    // Выводим аргументы
    printf("[%s] Количество аргументов: %d\n", argv[0], argc);
    for (int i = 0; i < argc; i++) {
        printf("Arg[%d]: %s\n", i, argv[i]);
    }

    // Получаем флаги stdin
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl");
        return 1;
    }
    // Устанавливаем файловый дескриптор stdin в неблокирующий режим
    if (fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl");
        return 1;
    }

    char buffer[1024]; // Увеличили размер буфера
    ssize_t bytes_read;

    fd_set rfds;
    struct timeval tv;
    int retval;

    // Ждем доступности данных во входном потоке в течение 1 секунды
    FD_ZERO(&rfds); // Очищаем множество
    FD_SET(STDIN_FILENO, &rfds); // Добавляем в множество
    tv.tv_sec = 0; 
    tv.tv_usec = 1; //  Не лучший вариант ждать 1 мс, но вариантов у меня просто не осталось, 
                    //      потому что с 0 он сообщяет о наличии данных, но кажется физически данных пока нет

    // Проверяем доступность
    retval = select(STDIN_FILENO + 1, &rfds, NULL, NULL, &tv);
    if (retval == -1) {
        perror("select");
        return 1;
        // Если есть данные доступные для чтения, читать
    } else if (retval) {
        // stdin готов к чтению
        bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer));
        if (bytes_read > 0) {
            // Данные доступны, выводим их
            printf("Прочитано из stdin: \n[-->'%.*s'<--]", (int)bytes_read, buffer);
        }
    } else {
        // Нет данных во входном потоке
        printf("Данные в stdin отсутствуют (нет данных для чтения).\n");
    }

    // Возвращаем stdin в блокирующий режим
    if (fcntl(STDIN_FILENO, F_SETFL, flags) == -1) {
        perror("fcntl");
        return 1;
    }

    printf("\n");
    return 0;
}
/*
int flags = fcntl(STDIN_FILENO, F_GETFL, 0);

fcntl() - это системный вызов в языке C, который позволяет осуществлять 
    различные операции с файловыми дескрипторами.
STDIN_FILENO - это макрос, представляющий стандартный файловый дескриптор 
    для стандартного ввода (stdin). Обычно его значение равно 0.
F_GETFL - это константа, используемая в качестве аргумента для fcntl(). 
    Она указывает, что мы хотим получить текущие флаги файла.
Последний аргумент, 0, используется, когда операция не требует дополнительных параметров.
Таким образом, эта строка кода запрашивает текущие флаги файла для стандартного 
    ввода (stdin) и сохраняет их значение в переменной flags. Если операция 
    завершится успешно, flags будет содержать текущие флаги файла. Если произойдет 
    ошибка, возвращается -1, и программа выводит сообщение об ошибке с помощью 
    perror() и завершается с кодом ошибки 1.

if (fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK) == -1) {
    perror("fcntl");
    return 1;
}

Эта строка кода вызывает fcntl() снова, чтобы установить новые флаги файла.
F_SETFL указывает, что мы хотим установить новые флаги для файла.
flags | O_NONBLOCK - это побитовая операция ИЛИ между текущими флагами flags и флагом 
    O_NONBLOCK. Это добавляет флаг O_NONBLOCK к текущим флагам файла, чтобы установить 
    файловый дескриптор в неблокирующий режим.
Если операция установки новых флагов завершится успешно, fcntl() вернет 0. В противном 
    случае, если произойдет ошибка, программа выведет сообщение об ошибке с помощью 
    perror() и завершится с кодом ошибки 1.
*/

/* Ну я пытался
    fd_set rfds;                  // Создаем множество дескрипторов файлов
    FD_ZERO(&rfds);               // Обнуляем множество
    FD_SET(0, &rfds);             // Добавляем stdin в множество
    struct timeval tv = {0, 1};   // Устанавливаем таймаут в 0 секунд и 1 микросекунду,
                                  // чтобы успевались считываться(далеко не лучшее решение, но я устал уже)
    
    // И оно всё еще работает неправильно, сдаюсь
    // Проверяем дескриптор 0
    if (select(1, &rfds, NULL, NULL, &tv) > 0) {
        const int size = 100;
        char buffer[size];
        printf("Прочитано из stdin: \n"); 
        while (fgets(buffer, sizeof(buffer), stdin) != NULL) {
            printf("%s", buffer); // Выводим считанные данные
        }
    } else {
        printf("Данные в stdin отсутствуют.\n");
    }


nfds: Это целое число, которое указывает на наибольший номер дескриптора файлов плюс 
    один в наборе дескрипторов.
readfds: Указатель на набор дескрипторов файлов для чтения.
writefds: Указатель на набор дескрипторов файлов для записи.
exceptfds: Указатель на набор дескрипторов файлов для исключений.
timeout: Указатель на структуру struct timeval, которая определяет максимальное 
    время ожидания для функции select().
Возвращаемое значение:

В случае успешного завершения функция select() возвращает количество дескрипторов, 
    на которых произошли изменения, и готовых к чтению, записи или исключениям.
В случае ошибки возвращается -1, и переменная errno устанавливается в соответствующий код ошибки.
*/

/*
Множество дескрипторов файлов:

Множество дескрипторов файлов - это структура данных, которая используется для отслеживания 
состояния нескольких файловых дескрипторов одновременно. Файловый дескриптор - это целое число, 
которое идентифицирует открытый файл в операционной системе.

В контексте данного вопроса, мы используем множество дескрипторов файлов для отслеживания состояния с
тандартного ввода (stdin). Таким образом, множество дескрипторов файлов позволяет нам проверить, 
готов ли stdin для чтения (т.е. содержит ли он данные для чтения).

Интервал ожидания:

В некоторых случаях, при ожидании событий ввода-вывода, нам может потребоваться установить временной 
интервал, в течение которого функция ожидания будет блокирована. Это полезно, когда мы хотим избежать 
бесконечного ожидания, если событие никогда не произойдет.

В контексте использования select() или poll() для проверки наличия данных в stdin, интервал ожидания 
определяет, сколько времени мы готовы ждать, прежде чем вернуть управление, даже если данных нет. 
Если интервал ожидания равен нулю, функция ожидания вернет управление немедленно.

Функции select() и poll() отслеживают изменения состояния набора файловых дескрипторов. 
Это включает в себя события, такие как:

    - Новые данные доступны для чтения (например, данные отправлены по сетевому соединению).
    - Данные доступны для записи (например, буфер для записи в сетевое соединение освободился).
    - Исключительные ситуации (например, ошибки или закрытие соединения).
Когда функция select() или poll() возвращает управление, она сообщает, на каких дескрипторах произошли 
эти изменения, чтобы приложение могло принять соответствующие действия.

select():

Использует наборы дескрипторов файлов для чтения, записи и исключений, представленные в виде структуры fd_set.
Ограничен максимальным значением максимального дескриптора, который может обрабатывать (FD_SETSIZE).

poll():

Использует массив структур pollfd, каждая из которых содержит информацию о файловом дескрипторе и о событиях, которые нужно отслеживать.
Не имеет жестких ограничений на количество дескрипторов, которые может обрабатывать.
*/